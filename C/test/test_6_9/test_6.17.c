#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>


////模拟实现qsort函数，用冒泡排序的思想
//
////交换函数
//void swap(char* k1, char* k2, int num_1)
//{
//	int i = 0;
//	for (i = 0; i < num_1; i++)
//	{
//		char tmp = 0;
//		tmp = *(k1 + i);
//		*(k1 + i) = *(k2 + i);
//		*(k2 + i) = tmp;
//	}
//}
//
////                 首地址   元素个数  元素长度    比较大小函数  
//int bubble_sort(void* base, int sz, int num, int(*cmp)(const void* e1, const void* e2))
//{
//	int i = 0;
//	//冒泡排序的趟数
//	for (i = 0; i < sz-1; i++)
//	{
//		//一趟的排序
//		int j = 0;
//		for (j = 0; j < sz - 1 - i; j++)
//		{
//			//if (cmp((const void*)((char*)base+j*num), (const void*)((char*)base + (j+1)*num)) > 0)
//			if (cmp((char*)base + j * num, (char*)base + (j + 1) * num) > 0)
//				//void*类型的指针不能进行加减操作
//			{
//				//交换
//				swap((char*)base + j * num, (char*)base + (j + 1) * num,num);
//			}
//		}
//	}
//}
//
//void print(int* arr, int sz_1)
//{
//	int i = 0;
//	for (i = 0; i < sz_1; i++)
//	{
//		printf("%d ", arr[i]);
//	}
//}
//
//int cmp_int(const void* e1, const void* e2)
//{
//	return *(int*)e1 - *(int*)e2;
//}
//
////整型数据排序
//void test1()
//{
//	int arr[] = { 9,8,7,6,5,4,3,2,1,0 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	//排序
//	bubble_sort(arr, sz,sizeof(arr[0]), cmp_int);
//	//打印
//	print(arr, sz);
//}
//
////结构体数据排序
////定义结构体类型
//struct Stu
//{
//	char name[20];
//	int age;
//};
//
//int sort_by_age(const void* e1, const void* e2)
//{
//	return (*(struct Stu*)e1).age - (*(struct Stu*)e2).age;//大于0交换
//}
//
//int sort_by_name(const void* e1, const void* e2)
//{
//	return strcmp((*(struct Stu*)e1).name ,(*(struct Stu*)e2).name);
//}
//
//void test2()
//{
//	struct Stu s[3] = { {"zhangsan",30},{"lisi",34},{"wangwu",20} };
//	//按照年龄来排序
//	int sz = sizeof(s) / sizeof(s[0]);
//	//bubble_sort(s, sz, sizeof(s[0]), sort_by_age);
//	//按照姓名排序
//	bubble_sort(s, sz, sizeof(s[0]), sort_by_name);
//}
//
//int main()
//{
//	//test1();
//	test2();
//	return 0;
//}


////整型数组
//int main()
//{
//	int a[] = { 1,2,3,4 };
//	printf("%d\n", sizeof(a));//16--计算的是数组a的长度，有4个元素，为整型类型，4个字节
//	printf("%d\n", sizeof(a + 0));//4/8--此处a表示的是数组首元素的地址，计算的是地址的大小
//	//32位元素的是4，64位的是8
//	printf("%d\n", sizeof(*a));//4--此处计算的是数组的第一个元素的大小，为整型，占4个字节
//	printf("%d\n", sizeof(a + 1));//4/8--此处a表示的是数组首元素的地址，计算的是数组第二个元素的地址的大小
//	printf("%d\n", sizeof(a[1]));//4--此处计算的是第二个元素的大小，为整型，占4个字节
//
//	printf("%d\n", sizeof(&a));//4/8--此处计算的是数组的地址的大小，但也是地址
//	printf("%d\n", sizeof(*&a));
//	//16--此处对数组取地址，获得数组地址，解引用后指向的是一个数组，所以此处计算的是数组的大小
//	printf("%d\n", sizeof(&a + 1));//4/8--此处计算的是数组之后的空间的地址的大小
//	printf("%d\n", sizeof(&a[0]));//4/8--此处计算的是数组第一个元素的地址
//	printf("%d\n", sizeof(&a[0] + 1));//4/8--此处计算的是数组第二个元素的地址
//
//	return 0;
//}


//字符数组
//#include<string.h>
//int main()
//{
//	char arr[] = { 'a','b','c','d','e','f' };//空间储存的是 a b c d e f
//	printf("%d\n", sizeof(arr));
//	//6--数组名单独在sizeof之中，数组名表示的是整个数组，计算的是整个数组的长度，故为6
//	printf("%d\n", sizeof(arr + 0));
//	//4/8--数组名没有单独在sizeof之中，所以数组名表示的是数组首元素的地址
//	//数组首元素的地址加0后，表示的还是数组首元素的地址
//	//所以sizeof计算的是数组首元素地址的长度，在32位环境中计算结果为4，在64位的环境下计算结果为8
//	printf("%d\n", sizeof(*arr));
//	//1--数组名没有单独在sizeof之中，所以数组名表示的是数组首元素的地址
//	//解引用之后就是数组的第一个元素a，所以sizeof计算的是元素a的长度，a为char类型，占一个字节的空间
//	printf("%d\n", sizeof(arr[1]));
//	//1--同上，sizeof计算的是元素a的长度，a为char类型，占一个字节的空间
//	printf("%d\n", sizeof(&arr));
//	//4/8--sizeof计算的是数组的地址的大小，因为计算的还是地址的大小
//	//所以在32位环境中计算结果为4，在64位的环境下计算结果为8
//	printf("%d\n", sizeof(&arr + 1));
//	//4/8--计算的是数组之后与该数组大小相同的空间的地址的大小，究其本质，计算的还是地址的大小
//	//所以在32位环境中计算结果为4，在64位的环境下计算结果为8
//	printf("%d\n", sizeof(&arr[0] + 1));
//	//4/8--计算的是数组第二个元素的地址的大小，所以在32位环境中计算结果为4，在64位的环境下计算结果为8
//
//	printf("%d\n", strlen(arr));
//	//随机值--arr表示数组的第一个元素，表示从数组的第一个元素开始计算字符数，直到遇到\0为止
//	//但该数组初始化的时候没有存储\0，所以\0的位置不知道在哪里，所以计算结果为随机值
//	printf("%d\n", strlen(arr + 0));
//	//随机值--同上，也是从数组的第一个元素开始计算字符数，因为\0的位置不知道在哪里，所以计算结果为随机值
//	printf("%d\n", strlen(*arr));
//	//错误--操作数应该是一个地址，此时操作数为数组首元素a，运行程序的时候会报错
//	printf("%d\n", strlen(arr[1]));
//	//错误--操作数应该是一个地址，此时操作数为数组元素b，运行程序的时候会报错
//	printf("%d\n", strlen(&arr));
//	//随机值--从数组的地址开始计算字符数，也就是数组首元素的地址
//	//因为\0的位置不知道在哪里，所以计算结果为随机值
//	printf("%d\n", strlen(&arr + 1));
//	//随机值--从数组之后与该数组大小相同的空间的地址开始计算字符数
//	//也就是该数组最后一个元素的地址加一字节的地址开始计算字符数
//	//因为\0的位置不知道在哪里，所以计算结果为随机值
//	printf("%d\n", strlen(&arr[0] + 1));
//	//随机值--从数组第二个元素的地址开始计算，因为\0的位置不知道在哪里，所以计算结果为随机值
//
//	return 0;
//}

//#include<string.h>
//int main()
//{
//	char arr[] = "abcdef";//空间存储的是 a b c d e f \0
//	printf("%d\n", sizeof(arr));
//	//7--数组名单独在sizeof之中，数组名表示的是整个数组，计算的是整个数组的长度，故为7
//	printf("%d\n", sizeof(arr + 0));
//	//4/8--数组名没有单独在sizeof之中，所以数组名表示的是数组首元素的地址
//	//数组首元素的地址加0后，表示的还是数组首元素的地址
//	//所以sizeof计算的是数组首元素地址的长度，在32位环境中计算结果为4，在64位的环境下计算结果为8
//	printf("%d\n", sizeof(*arr));
//	//1--数组名没有单独在sizeof之中，所以数组名表示的是数组首元素的地址
//	//解引用之后就是数组的第一个元素a，所以sizeof计算的是元素a的长度，a为char类型，占一个字节的空间
//	printf("%d\n", sizeof(arr[1]));
//	//1--同上，sizeof计算的是元素a的长度，a为char类型，占一个字节的空间
//	printf("%d\n", sizeof(&arr));
//	//4/8--sizeof计算的是数组的地址的大小，因为计算的还是地址的大小
//	//所以在32位环境中计算结果为4，在64位的环境下计算结果为8
//	printf("%d\n", sizeof(&arr + 1));
//	//4/8--计算的是数组之后与该数组大小相同的空间的地址的大小，究其本质，计算的还是地址的大小
//    //所以在32位环境中计算结果为4，在64位的环境下计算结果为8
//	printf("%d\n", sizeof(&arr[0] + 1));
//	//4/8--计算的是数组第二个元素的地址的大小，所以在32位环境中计算结果为4，在64位的环境下计算结果为8
//
//	printf("%d\n", strlen(arr));
//	//6--arr表示数组的第一个元素，表示从数组的第一个元素开始计算字符数，直到遇到\0为止,\0不计算在内
//	printf("%d\n", strlen(arr + 0));
//	//6--同上，也是从数组的第一个元素开始计算字符数，所以计算结果为6
//	printf("%d\n", strlen(*arr));
//	//错误--操作数应该是一个地址，此时操作数为数组首元素a，运行程序的时候会报错
//	printf("%d\n", strlen(arr[1]));
//	//错误--操作数应该是一个地址，此时操作数为数组元素b，运行程序的时候会报错
//	printf("%d\n", strlen(&arr));
//	//6--从数组的地址开始计算字符数，也就是数组首元素的地址，所以计算结果为6
//	printf("%d\n", strlen(&arr + 1));
//	//随机值--从数组之后与该数组大小相同的空间的地址开始计算字符数
//	//也就是该数组最后一个元素的地址加一字节的地址开始计算字符数
//	//因为\0的位置不知道在哪里，所以计算结果为随机值
//	printf("%d\n", strlen(&arr[0] + 1));
//	//5--从数组第二个元素的地址开始计算，因为\0的位置不知道在哪里，所以计算结果为5
//
//	return 0;
//}

//#include<string.h>
//int main()
//{
//	char* p = "abcdef";//空间存储的是 a b c d e f \0
//	printf("%d\n", sizeof(p));
//	//4/8--p为字符型指针变量，里面存储的是字符串的地址，所以计算的是地址的大小
//	//所以在32位环境中计算结果为4，在64位的环境下计算结果为8
//	printf("%d\n", sizeof(p + 1));
//	//4/8--p为字符型指针变量，里面存储的是字符串的地址，实际存储的是字符串首元素的地址，即字符a的地址
//	//因为计算的是地址的大小，所以在32位环境中计算结果为4，在64位的环境下计算结果为8
//	printf("%d\n", sizeof(*p));
//	//1--p为字符型指针变量，里面存储的是字符串的地址，实际存储的是字符串首元素的地址，即字符a的地址
//	//解引用操作后，*p指的是字符a，所以此处计算的是字符a的大小，计算结果为1
//	printf("%d\n", sizeof(p[0]));
//	//1--同上，p[0]表示的是a，所以此处计算的是字符a的大小，计算结果为1
//	printf("%d\n", sizeof(&p));
//	//4/8--此处计算的是字符型指针变量p的地址的大小
//	//因为计算的是地址的大小，所以在32位环境中计算结果为4，在64位的环境下计算结果为8
//	printf("%d\n", sizeof(&p + 1));
//	//4/8--此处计算的是字符型指针变量p的地址加一字节后地址的大小
//	//因为计算的是地址的大小，所以在32位环境中计算结果为4，在64位的环境下计算结果为8
//	printf("%d\n", sizeof(&p[0] + 1));
//	//4/8--此处计算的是字符串第二个字符的地址的大小
//	//因为计算的是地址的大小，所以在32位环境中计算结果为4，在64位的环境下计算结果为8
//
//	printf("%d\n", strlen(p));
//	//6--p为字符型指针变量，里面存储的是字符串的地址，实际存储的是字符串首元素的地址，即字符a的地址
//	//此处从字符a开始计算字符数，遇到\0为止，所以计算结果为6
//	printf("%d\n", strlen(p + 1));
//	//5--p为字符型指针变量，里面存储的是字符串的地址，实际存储的是字符串首元素的地址，即字符a的地址
//	//此处从字符b开始计算字符数，遇到\0为止，所以计算结果为5
//	printf("%d\n", strlen(*p));
//	//错误--操作数应该是一个地址，此时操作数为字符串首元素a，运行程序的时候会报错
//	printf("%d\n", strlen(p[0]));
//	//错误--操作数应该是一个地址，此时操作数为字符串首元素a，运行程序的时候会报错
//	printf("%d\n", strlen(&p));
//	//随机值--此处从字符型指针变量p的地址开始计算字符数，因为\0的位置不知道在哪里，所以计算结果为随机值
//	printf("%d\n", strlen(&p + 1));
//	//随机值--此处从字符型指针变量p的地址后一字节处开始计算字符数
//	//因为\0的位置不知道在哪里，所以计算结果为随机值
//	printf("%d\n", strlen(&p[0] + 1));
//	//5--此处从字符b开始计算字符数，遇到\0为止，所以计算结果为5
//
//	return 0;
//}


//二维数组
//int main()
//{
//	int a[3][4] = { 0 };
//	printf("%d\n", sizeof(a));
//	//48--数组名单独在sizeof之中，数组名表示的是整个数组，计算的是整个数组的长度
//	//整个数组有12个整型元素，一个整型元素占4个字节，所以整个数组的大小为12*4==48
//	printf("%d\n", sizeof(a[0][0]));
//	//4--此处计算的是二维数组的第一行第一列的元素的大小，该元素为整型，所以计算结果为4
//	printf("%d\n", sizeof(a[0]));
//	//16--此处计算的是二维数组的首元素的大小，二维数组的首元素为二维数组的第一行
//	//第一行有4个元素，每个元素为整型，所以计算结果为4*4==16
//	printf("%d\n", sizeof(a[0]+1));
//	//4/8--在二维数组中，可以将二维数组的每一行看成一个一维数组，那么a[0]就是二维数组第一个一维数组的数组名
//	//而数组名可以表示数组首元素的地址，所以此处计算的是第一行第二列元素的地址的大小
//	// 因为计算的是地址的大小，所以在32位环境中计算结果为4，在64位的环境下计算结果为8
//	printf("%d\n", sizeof(*(a[0]+1)));
//	//4--根据上述，(a[0]+1)表示的是二维数组第一行第二列元素的地址，对其解引用，得到的就是二维数组第一行第二列元素
//	//此处计算的是二维数组的第一行第二列的元素的大小，该元素为整型，所以计算结果为4
//	printf("%d\n", sizeof(a+1));
//	//4/8--数组名没有单独在sizeof之中，所以数组名表示的是数组首元素的地址,所以此处计算的是二维数组第二个元素的地址
//	// 因为计算的是地址的大小，所以在32位环境中计算结果为4，在64位的环境下计算结果为8
//	printf("%d\n", sizeof(*(a+1)));
//	//16--根据上述，(a+1)表示的是二维数组第二个元素的地址，解引用后得到的是二维数组的第二个元素
//	//此处计算的是二维数组的第二个元素的大小，二维数组的第二个元素为二维数组的第二行
//	//第二行有4个元素，每个元素为整型，所以计算结果为4*4==16
//	printf("%d\n", sizeof(&a[0]+1));
//	//4/8--&a[0]表示的是二维数组的首元素的地址，&a[0]+1表示的就是二维数组第二个元素的地址
//	// 因为计算的是地址的大小，所以在32位环境中计算结果为4，在64位的环境下计算结果为8
//	printf("%d\n", sizeof(*(&a[0]+1)));
//	//16--&a[0]表示的是二维数组的首元素的地址，&a[0]+1表示的就是二维数组第二个元素的地址
//	//解引用后得到的是二维数组的第二个元素
//	//此处计算的是二维数组的第二个元素的大小，二维数组的第二个元素为二维数组的第二行
//	//第二行有4个元素，每个元素为整型，所以计算结果为4*4==16
//	printf("%d\n", sizeof(*a));
//	//16--数组名没有单独在sizeof之中，所以数组名表示的是数组首元素的地址,解引用后得到的是二维数组的首元素
//	//此处计算的是二维数组的首元素的大小，二维数组的首元素为二维数组的第一行
//	//第一行有4个元素，每个元素为整型，所以计算结果为4*4==16
//	printf("%d\n", sizeof(a[3]));
//	//16--此处计算的是二维数组的第四个元素，但该二维数组只有三个元素，这属于越界访问
//	//但一个变量有两个属性，一个是值数组，一个是类型属性，此处就是根据a[3]的类型属性来计算出的结果
//	return 0;
//}


////指针练习1
//int main()
//{
//	int a[5] = { 1,2,3,4,5 };
//	int* p = (int*)(&a + 1);
//	printf("%d,%d", *(a + 1), *(p - 1));
//	return 0;
//}


////指针练习2
//struct test
//{
//	int num;
//	char* name;
//	short date;
//	char a[2];
//	short b[4];
//}*p;
////假设p的值为0x100000。
////已知结构体test类型的变量大小是20个字节
//int main()
//{
//	printf("%p\n", p + 0x1);
//	printf("%p\n", (unsigned long)p + 0x1);
//	printf("%p\n", (unsigned int*)p + 0x1);
//	return 0;
//}

////指针类型
//int main()
//{
//	int a = 0;
//	char b = '0';
//	int* pa = &a;
//	char* pb = &b;
//	return 0;
//}

//int main()
//{
//	int a = 3;
//	char b = '0';
//	int* pa = &a;//定义整型指针
//	char* pb = &b;//定义字符指针
//	int* pa1 = &a;//定义数组指针
//	char* pa2 = &a;
//	pa1++;
//	pa2++;
//	printf("%p\n", &a);
//	printf("%p\n", pa1);
//	printf("%p\n", pa2);
//	return 0;
//}